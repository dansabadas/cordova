<document>
    <body>
        <div id="subTree">
            <form>
            <input type="text"/>
            </form>
            <p>Paragraph</p>
            <span>Span</span>
            </div>
            <input id="first"/>
            <input id="second"/>
    </body>
    <script
        src="https://code.jquery.com/jquery-3.3.1.js"
        integrity="sha256-2Kok7MbOyxpgUVvAk/HJ2jigOSYS2auK4Pfzbm7uH60="
        crossorigin="anonymous"></script>
    <script>
        let assert = console.assert;
        let log = console.log;
        function traverseDOM(element, callback) {
            callback(element);
            element = element.firstElementChild;
            while (element) {
                traverseDOM(element, callback);
                element = element.nextElementSibling;
            }
        }

        function* DomTraversal(element){
            yield element;
            element = element.firstElementChild;
            while (element) {
                yield* DomTraversal(element);
                element = element.nextElementSibling;
            }
        }

        const subTree = document.getElementById("subTree");
        traverseDOM(subTree, function(element) {
            log(element !== null, element.nodeName);
        });

        for(let element of DomTraversal(subTree)) {
            log(element !== null, element.nodeName);
        }

        function* NinjaGenerator(action) {
            const imposter = yield ("Hattori " + action);
            log(imposter === "Hanzo", "The generator has been infiltrated");
            yield ("Yoshi (" + imposter + ") " + action);
        }

        const ninjaIterator = NinjaGenerator("skulk");
        const result1 = ninjaIterator.next();
        log(result1.value === "Hattori skulk", "Hattori is skulking");
        const result2 = ninjaIterator.next("Hanzo");
        log(result2.value === "Yoshi (Hanzo) skulk", "We have an imposter!");

        const ninjaPromise = new Promise((resolve, reject) => {
            log('123...');
            resolve("Hattori");
            //reject("An error resolving a promise!");
        });
        log('cantautor');
        ninjaPromise.then(ninja => {
            log(ninja === "Hattori", "We were promised Hattori!");
        }, err => {
            fail("There shouldn't be an error")
        });

        const explicitRejectPromise = new Promise((resolve, reject) => {
            reject("Explicitly reject a promise!");
        });

        explicitRejectPromise.then(
            () => fail("Happy path, won't be called!"),
            error => log(error, "A promise was explicitly rejected!")
        );

        const implicitRejectPromise = new Promise((resolve, reject) => {
            undeclaredVariable++;
        });
                
        implicitRejectPromise
            .then(() => fail("Happy path, won't be called!"))
            .catch(error => log(error, "Third promise was also rejected"));

        function getJSON(url) {
            return new Promise((resolve, reject) => {
                const request = new XMLHttpRequest();
                request.open("GET", url);
                request.onload = function() {
                    try {
                        if(this.status === 200 ){
                        resolve(JSON.parse(this.response));
                        } else{
                        reject(this.status + " " + this.statusText);
                        }
                    } catch(e){
                        reject(e.message);
                    }
                };
                request.onerror = function() {
                    reject(this.status + " " + this.statusText);
                };

                request.send();
            });
        }

        getJSON("data/ninjas.json").then(ninjas => {
        log(ninjas !== null, ninjas, "Ninjas obtained!");
        }).catch(e => log("Shouldn't be here:" + e));

        getJSON("data/ninjas.json")
            .then(ninjas => {log(ninjas, "Ninja missions obtained!"); getJSON(ninjas[0].missionsUrl);})
            .then(missions => log(missions, "Ninja missions obtained!"))
            .catch(error => log(error, "An error has occurred"));

            Promise
                .all([getJSON("data/ninjas.json"),
                    getJSON("data/missions.json")])
                .then(results => {
                    const ninjas = results[0], missions = results[1];
                    log(ninjas, missions, "The plan is ready to be set in motion!");
                }).catch(error => {
                    log("A problem in carrying out our plan!");
                });

            Promise
                .race([getJSON("data/ninjas.json"),
                    getJSON("data/missions.json")])
                .then(ninja => {
                    log(ninja, "race!");
                }).catch(error => {
                    log("A problem in carrying out our plan!");
                });

                async(function*(){
                    try {
                        const ninjas = yield getJSON("data/ninjas.json");
                        log("ninjas", ninjas);
                        const missions = yield getJSON(ninjas[0].missionsUrl);
                        log("missions", missions);
                        //Study the mission details
                    }
                    catch(e) {
                        //Oh no, we weren't able to get the mission details
                    }
                });

                function async(generator) {
                    var iterator = generator();
                    function handle(iteratorResult) {
                        if(iteratorResult.done) { return; }
                        const iteratorValue = iteratorResult.value;
                        if(iteratorValue instanceof Promise) {
                            iteratorValue
                                .then(res => handle(iterator.next(res)))
                                .catch(err => iterator.throw(err));
                        }
                    }
                    try {
                        handle(iterator.next());
                    }
                    catch (e) { iterator.throw(e); }
                }
                
                log('the end of 6');
                const promise = new Promise((resolve, reject) => {
                    resolve("Hattori");
                    setTimeout(()=> reject("Yoshi"), 500);
                });
                promise
                    .then(val => log("Success chapter 6: " + val))
                    .catch(e => log("Error chapter 6: " + e));

            let report = console.log;
            function Ninja() {
                let _skillLevel = 0;
                Object.defineProperty(this, 'skillLevel', {
                    get: () => {
                        report("The get method is called");
                        return _skillLevel;
                    },
                    set: value => {
                        report("The set method is called");
                        _skillLevel = value;
                    }
                });
            }

            const ninja = new Ninja();
            log(typeof ninja._skillLevel === "undefined", "We cannot access a 'private' property");
            log(ninja.skillLevel === 0, "The getter works fine!");
            ninja.skillLevel = 10;
            log(ninja.skillLevel === 10, "The value was updated");

            const emperor = { name: "Komei" };
            const representative = new Proxy(emperor, {
                get: (target, key) => {
                    report("Reading " + key + " through a proxy");
                    return key in target ? target[key] : "Don't bother the emperor!"
                },
                set: (target, key, value) => {
                    report("Writing " + key + " through a proxy");
                    target[key] = value;
                }
            });

            log(emperor.name === "Komei", "The emperor's name is Komei");
            log(representative.name === "Komei", "We can get the name property through a proxy");
            log(emperor.nickname === undefined, "The emperor doesn’t have a nickname ");
            log(representative.nickname === "Don't bother the emperor!", "The proxy jumps in when we make inproper requests");
            representative.nickname = "Tenno";
            log(emperor.nickname === "Tenno", "The emperor now has a nickname");
            log(representative.nickname === "Tenno", "The nickname is also accessible through the proxy");

            function isPrime(number){
                if(number < 2) { return false; }
                for(let i = 2; i < number; i++) {
                    if(number % i === 0) { return false; }
                }

                return true;
            }

            isPrime = new Proxy(isPrime, {
                apply: (target, thisArg, args) => {
                    console.time("isPrime");
                    log("args=", args);
                    const result = target.apply(thisArg, args);
                    console.timeEnd("isPrime");
                    return result;
                }
            });

            isPrime(1299827);

            function Folder() {
                return new Proxy({}, {
                    get: (target, property) => {
                        report("Reading " + property);
                        if(!(property in target)) {
                            target[property] = new Folder();
                        }
                        return target[property];
                    }
                });
            }

            const rootFolder = new Folder();
            try {
                rootFolder.ninjasDir.firstNinjaDir.ninjaFile = "yoshi.txt";
                log("An exception wasn’t raised", rootFolder);
            }
            catch(e){
                log("An exception has occurred");
            }

            function createNegativeArrayProxy(array){
                if (!Array.isArray(array)) {
                    throw new TypeError('Expected an array');
                }
                return new Proxy(array, {
                    get: (target, index) => {
                        index = +index;
                        return target[index < 0 ? target.length + index : index];
                    },
                    set: (target, index, val) => {
                        index = +index;
                        return target[index < 0 ? target.length + index : index] = val;
                    }
                });
            }

            function measure(items){
                const startTime = new Date().getTime();
                for(let i = 0; i < 500000; i++){
                    items[0] === "Yoshi";
                    items[1] === "Kuma";
                    items[2] === "Hattori";
                }

                return new Date().getTime() - startTime;
            }

            const ninjas = ["Yoshi", "Kuma", "Hattori"];
            const proxiedNinjas = createNegativeArrayProxy(ninjas);
            console.log("Proxies are around", Math.round(measure(proxiedNinjas)/ measure(ninjas)), "times slower");

            const ninjas2 = ["Yagyu", "Kuma", "Hattori", "Fuma"];
            var removedItems = ninjas2.splice(1, 1);
            log(removedItems.length === 1, "One item was removed");
            log(removedItems[0] === "Kuma");

            const ninjas3 = ["Yagyu", "Kuma", "Hattori"];
            for(let i = 0; i < ninjas3.length; i++){
                log(ninjas3[i] !== null, ninjas3[i]);
            }
            ninjas3.forEach(ninja => {
                log(ninja !== null, ninja);
            });

            const ninjas4 = [
                {name: "Yagyu", weapon: "shuriken"},
                {name: "Yoshi" },
                {name: "Kuma", weapon: "wakizashi"}
            ];
            const weapons = ninjas4.map(ninja => ninja.weapon);
            weapons.forEach(w => {
                log("w= ", w);
            });
            const ninjaWithWakizashi = ninjas4.find(ninja => {
                return ninja.weapon === "wakizashi";
            });
            const armedNinjas = ninjas4.filter(ninja => "weapon" in ninja);
            log("ninjaWithWakizashi=", ninjaWithWakizashi);
            log("armedNinjas=", armedNinjas);

            const numbers = [1, 2, 3, 4];
            const sum = numbers.reduce((aggregated, number) => aggregated + number, 0);
            log(sum === 10, "The sum of first four numbers is 10");

            const elems = {
                length: 0,
                add: function(elem){
                    Array.prototype.push.call(this, elem);
                },
                gather: function(id){
                    this.add(document.getElementById(id));
                },
                find: function(callback){
                    return Array.prototype.find.call(this, callback);
                }
            };
            elems.gather("first");
            log(elems.length === 1 && elems[0].nodeType,
            "Verify that we have an element in our stash");
            elems.gather("second");
            log(elems.length === 2 && elems[1].nodeType,
            "Verify the other insertion");
            var found = elems.find(elem => elem.id === "second");
            log(found && found.id === "second",
            "We've found our element");

            //defective keys in javascript () keys that are not strings but objects => toString invocation
            const firstElement = document.getElementById("firstElement");
            const secondElement = document.getElementById("secondElement");
            const map = {};
            map[firstElement] = { data: "firstElement"};
            log(map[firstElement].data === "firstElement",
            "The first element is correctly mapped");
            map[secondElement] = { data: "secondElement"};
            log(map[secondElement].data === "secondElement",
            "The second element is correctly mapped");
            log(map[firstElement].data === "firstElement",
            "But now the firstElement is overriden!");

            const map2 = new Map();
            const currentLocation = location.href;
            const firstLink = new URL(currentLocation);
            const secondLink = new URL(currentLocation);
            map2.set(firstLink, { description: "firstLink"});
            map2.set(secondLink, { description: "secondLink"});

            assert(map2.get(firstLink).description === "firstLink",
            "First link mapping" );
            assert(map2.get(secondLink).description === "secondLink",
            "Second link mapping");
            assert(map2.size === 2, "There are two mappings");

            const directory = new Map();
            directory.set("Yoshi", "+81 26 6462");
            directory.set("Kuma", "+81 52 2378 6462");
            directory.set("Hiro", "+81 76 277 46");

            for(let item of directory){
                log(item[0] !== null, "Key:" + item[0]);
                log(item[1] !== null, "Value:" + item[1]);
            }
            for(let key of directory.keys()){
                log(key !== null, "Key:" + key);
                log(directory.get(key) != null,
                "Value:" + directory.get(key));
            }
            for(var value of directory.values()){
                log(value !== null, "Value:" + value);
            }

        </script>
</document>