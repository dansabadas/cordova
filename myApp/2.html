<document>
    <body>
        <div id="subTree">
            <form>
            <input type="text"/>
            </form>
            <p>Paragraph</p>
            <span>Span</span>
            </div>
            <input id="first"/>
            <input id="second"/>
    </body>
    <script
        src="https://code.jquery.com/jquery-3.3.1.js"
        integrity="sha256-2Kok7MbOyxpgUVvAk/HJ2jigOSYS2auK4Pfzbm7uH60="
        crossorigin="anonymous"></script>
    <script>
        let assert = console.assert;
        let log = console.log;
        function traverseDOM(element, callback) {
            callback(element);
            element = element.firstElementChild;
            while (element) {
                traverseDOM(element, callback);
                element = element.nextElementSibling;
            }
        }

        function* DomTraversal(element){
            yield element;
            element = element.firstElementChild;
            while (element) {
                yield* DomTraversal(element);
                element = element.nextElementSibling;
            }
        }

        const subTree = document.getElementById("subTree");
        traverseDOM(subTree, function(element) {
            log(element !== null, element.nodeName);
        });

        for(let element of DomTraversal(subTree)) {
            log(element !== null, element.nodeName);
        }

        function* NinjaGenerator(action) {
            const imposter = yield ("Hattori " + action);
            log(imposter === "Hanzo", "The generator has been infiltrated");
            yield ("Yoshi (" + imposter + ") " + action);
        }

        const ninjaIterator = NinjaGenerator("skulk");
        const result1 = ninjaIterator.next();
        log(result1.value === "Hattori skulk", "Hattori is skulking");
        const result2 = ninjaIterator.next("Hanzo");
        log(result2.value === "Yoshi (Hanzo) skulk", "We have an imposter!");

        const ninjaPromise = new Promise((resolve, reject) => {
            log('123...');
            resolve("Hattori");
            //reject("An error resolving a promise!");
        });
        log('cantautor');
        ninjaPromise.then(ninja => {
            log(ninja === "Hattori", "We were promised Hattori!");
        }, err => {
            fail("There shouldn't be an error")
        });

        const explicitRejectPromise = new Promise((resolve, reject) => {
            reject("Explicitly reject a promise!");
        });

        explicitRejectPromise.then(
            () => fail("Happy path, won't be called!"),
            error => log(error, "A promise was explicitly rejected!")
        );

        const implicitRejectPromise = new Promise((resolve, reject) => {
            undeclaredVariable++;
        });
                
        implicitRejectPromise
            .then(() => fail("Happy path, won't be called!"))
            .catch(error => log(error, "Third promise was also rejected"));

        function getJSON(url) {
            return new Promise((resolve, reject) => {
                const request = new XMLHttpRequest();
                request.open("GET", url);
                request.onload = function() {
                    try {
                        if(this.status === 200 ){
                        resolve(JSON.parse(this.response));
                        } else{
                        reject(this.status + " " + this.statusText);
                        }
                    } catch(e){
                        reject(e.message);
                    }
                };
                request.onerror = function() {
                    reject(this.status + " " + this.statusText);
                };

                request.send();
            });
        }

        getJSON("data/ninjas.json").then(ninjas => {
        log(ninjas !== null, ninjas, "Ninjas obtained!");
        }).catch(e => log("Shouldn't be here:" + e));

        getJSON("data/ninjas.json")
            .then(ninjas => {log(ninjas, "Ninja missions obtained!"); getJSON(ninjas[0].missionsUrl);})
            .then(missions => log(missions, "Ninja missions obtained!"))
            .catch(error => log(error, "An error has occurred"));

            Promise
                .all([getJSON("data/ninjas.json"),
                    getJSON("data/missions.json")])
                .then(results => {
                    const ninjas = results[0], missions = results[1];
                    log(ninjas, missions, "The plan is ready to be set in motion!");
                }).catch(error => {
                    log("A problem in carrying out our plan!");
                });

            Promise
                .race([getJSON("data/ninjas.json"),
                    getJSON("data/missions.json")])
                .then(ninja => {
                    log(ninja, "race!");
                }).catch(error => {
                    log("A problem in carrying out our plan!");
                });

                async(function*(){
                    try {
                        const ninjas = yield getJSON("data/ninjas.json");
                        log("ninjas", ninjas);
                        const missions = yield getJSON(ninjas[0].missionsUrl);
                        log("missions", missions);
                        //Study the mission details
                    }
                    catch(e) {
                        //Oh no, we weren't able to get the mission details
                    }
                });

                function async(generator) {
                    var iterator = generator();
                    function handle(iteratorResult) {
                        if(iteratorResult.done) { return; }
                        const iteratorValue = iteratorResult.value;
                        if(iteratorValue instanceof Promise) {
                            iteratorValue
                                .then(res => handle(iterator.next(res)))
                                .catch(err => iterator.throw(err));
                        }
                    }
                    try {
                        handle(iterator.next());
                    }
                    catch (e) { iterator.throw(e); }
                }
                
                log('the end of 6');
                const promise = new Promise((resolve, reject) => {
                    resolve("Hattori");
                    setTimeout(()=> reject("Yoshi"), 500);
                });
                promise
                    .then(val => log("Success chapter 6: " + val))
                    .catch(e => log("Error chapter 6: " + e));

            let report = console.log;
            function Ninja() {
                let _skillLevel = 0;
                Object.defineProperty(this, 'skillLevel', {
                    get: () => {
                        report("The get method is called");
                        return _skillLevel;
                    },
                    set: value => {
                        report("The set method is called");
                        _skillLevel = value;
                    }
                });
            }

            const ninja = new Ninja();
            log(typeof ninja._skillLevel === "undefined", "We cannot access a 'private' property");
            log(ninja.skillLevel === 0, "The getter works fine!");
            ninja.skillLevel = 10;
            log(ninja.skillLevel === 10, "The value was updated");

            const emperor = { name: "Komei" };
            const representative = new Proxy(emperor, {
                get: (target, key) => {
                    report("Reading " + key + " through a proxy");
                    return key in target ? target[key] : "Don't bother the emperor!"
                },
                set: (target, key, value) => {
                    report("Writing " + key + " through a proxy");
                    target[key] = value;
                }
            });

            log(emperor.name === "Komei", "The emperor's name is Komei");
            log(representative.name === "Komei", "We can get the name property through a proxy");
            log(emperor.nickname === undefined, "The emperor doesn’t have a nickname ");
            log(representative.nickname === "Don't bother the emperor!", "The proxy jumps in when we make inproper requests");
            representative.nickname = "Tenno";
            log(emperor.nickname === "Tenno", "The emperor now has a nickname");
            log(representative.nickname === "Tenno", "The nickname is also accessible through the proxy");

            function isPrime(number){
                if(number < 2) { return false; }
                for(let i = 2; i < number; i++) {
                    if(number % i === 0) { return false; }
                }

                return true;
            }

            isPrime = new Proxy(isPrime, {
                apply: (target, thisArg, args) => {
                    console.time("isPrime");
                    log("args=", args);
                    const result = target.apply(thisArg, args);
                    console.timeEnd("isPrime");
                    return result;
                }
            });

            isPrime(1299827);

            function Folder() {
                return new Proxy({}, {
                    get: (target, property) => {
                        report("Reading " + property);
                        if(!(property in target)) {
                            target[property] = new Folder();
                        }
                        return target[property];
                    }
                });
            }

            const rootFolder = new Folder();
            try {
                rootFolder.ninjasDir.firstNinjaDir.ninjaFile = "yoshi.txt";
                log("An exception wasn’t raised", rootFolder);
            }
            catch(e){
                log("An exception has occurred");
            }

            function createNegativeArrayProxy(array){
                if (!Array.isArray(array)) {
                    throw new TypeError('Expected an array');
                }
                return new Proxy(array, {
                    get: (target, index) => {
                        index = +index;
                        return target[index < 0 ? target.length + index : index];
                    },
                    set: (target, index, val) => {
                        index = +index;
                        return target[index < 0 ? target.length + index : index] = val;
                    }
                });
            }

            function measure(items){
                const startTime = new Date().getTime();
                for(let i = 0; i < 500000; i++){
                    items[0] === "Yoshi";
                    items[1] === "Kuma";
                    items[2] === "Hattori";
                }

                return new Date().getTime() - startTime;
            }

            const ninjas = ["Yoshi", "Kuma", "Hattori"];
            const proxiedNinjas = createNegativeArrayProxy(ninjas);
            console.log("Proxies are around", Math.round(measure(proxiedNinjas)/ measure(ninjas)), "times slower");

            const ninjas2 = ["Yagyu", "Kuma", "Hattori", "Fuma"];
            var removedItems = ninjas2.splice(1, 1);
            log(removedItems.length === 1, "One item was removed");
            log(removedItems[0] === "Kuma");

            const ninjas3 = ["Yagyu", "Kuma", "Hattori"];
            for(let i = 0; i < ninjas3.length; i++){
                log(ninjas3[i] !== null, ninjas3[i]);
            }
            ninjas3.forEach(ninja => {
                log(ninja !== null, ninja);
            });

            const ninjas4 = [
                {name: "Yagyu", weapon: "shuriken"},
                {name: "Yoshi" },
                {name: "Kuma", weapon: "wakizashi"}
            ];
            const weapons = ninjas4.map(ninja => ninja.weapon);
            weapons.forEach(w => {
                log("w= ", w);
            });
            const ninjaWithWakizashi = ninjas4.find(ninja => {
                return ninja.weapon === "wakizashi";
            });
            const armedNinjas = ninjas4.filter(ninja => "weapon" in ninja);
            log("ninjaWithWakizashi=", ninjaWithWakizashi);
            log("armedNinjas=", armedNinjas);

            const numbers = [1, 2, 3, 4];
            const sum = numbers.reduce((aggregated, number) => aggregated + number, 0);
            log(sum === 10, "The sum of first four numbers is 10");

            const elems = {
                length: 0,
                add: function(elem){
                    Array.prototype.push.call(this, elem);
                },
                gather: function(id){
                    this.add(document.getElementById(id));
                },
                find: function(callback){
                    return Array.prototype.find.call(this, callback);
                }
            };
            elems.gather("first");
            log(elems.length === 1 && elems[0].nodeType,
            "Verify that we have an element in our stash");
            elems.gather("second");
            log(elems.length === 2 && elems[1].nodeType,
            "Verify the other insertion");
            var found = elems.find(elem => elem.id === "second");
            log(found && found.id === "second",
            "We've found our element");

            //defective keys in javascript () keys that are not strings but objects => toString invocation
            const firstElement = document.getElementById("firstElement");
            const secondElement = document.getElementById("secondElement");
            const map = {};
            map[firstElement] = { data: "firstElement"};
            log(map[firstElement].data === "firstElement",
            "The first element is correctly mapped");
            map[secondElement] = { data: "secondElement"};
            log(map[secondElement].data === "secondElement",
            "The second element is correctly mapped");
            log(map[firstElement].data === "firstElement",
            "But now the firstElement is overriden!");

            const map2 = new Map();
            const currentLocation = location.href;
            const firstLink = new URL(currentLocation);
            const secondLink = new URL(currentLocation);
            map2.set(firstLink, { description: "firstLink"});
            map2.set(secondLink, { description: "secondLink"});

            assert(map2.get(firstLink).description === "firstLink",
            "First link mapping" );
            assert(map2.get(secondLink).description === "secondLink",
            "Second link mapping");
            assert(map2.size === 2, "There are two mappings");

            const directory = new Map();
            directory.set("Yoshi", "+81 26 6462");
            directory.set("Kuma", "+81 52 2378 6462");
            directory.set("Hiro", "+81 76 277 46");

            for(let item of directory){
                log(item[0] !== null, "Key:" + item[0]);
                log(item[1] !== null, "Value:" + item[1]);
            }
            for(let key of directory.keys()){
                log(key !== null, "Key:" + key);
                log(directory.get(key) != null,
                "Value:" + directory.get(key));
            }
            for(var value of directory.values()){
                log(value !== null, "Value:" + value);
            }

            const tags =  /^(area|base|br|col|embed|hr|img|input|keygen|link|menuitem|meta|param|source|track|wbr)$/i;
            function convert(html) {
                return html.replace(/(<(\w+)[^>]*?)\/>/g, (all, front, tag) => {
                    return tags.test(tag) ? all : front + "></" + tag + ">";
                });
            }
            log(convert("<a/>") === "<a></a>", "Check anchor conversion.");
            log(convert("<hr/>") === "<hr/>", "Check hr conversion.");

            function getNodes(htmlString, doc) {
                const map = {
                    "<td":[3,"<table><tbody><tr>","</tr></tbody></table>"],
                    "<th":[3,"<table><tbody><tr>","</tr></tbody></table>"],
                    "<tr":[2,"<table><thead>","</thead></table>"],
                    "<option":[1,"<select multiple>","</select>"],
                    "<optgroup":[1,"<select multiple>","</select>"],
                    "<legend":[1,"<fieldset>","</fieldset>"],
                    "<thead":[1,"<table>","</table>"],
                    "<tbody":[1,"<table>","</table>"],
                    "<tfoot":[1,"<table>","</table>"],
                    "<colgroup":[1,"<table>","</table>"],
                    "<caption":[1,"<table>","</table>"],
                    "<col":[2,"<table><tbody></tbody><colgroup>","</colgroup></table>"]
                };

                const tagName = htmlString.match(/<\w+/);
                let mapEntry = tagName ? map[tagName[0]] : null;
                if (!mapEntry) { mapEntry = [0, " "," " ];}
                let div = (doc || document).createElement("div");
                div.innerHTML = mapEntry[1] + htmlString + mapEntry[2];
                while (mapEntry[0]--) { div = div.lastChild; }
                if (fragment) {
                    while (div.firstChild) {
                        fragment.appendChild(div.firstChild);
                    }
                }

                return div.childNodes; 
            }

            //log(getNodes("<td>test</td><td>test2</td>").length === 2, "Get two nodes back from the method.");
            //log(getNodes("<td>test</td>")[0].nodeName === "TD", "Verify that we're getting the right node.");

            function green(){
                let a = 2;
                return function yellow(){
                    return a++;
                }
            }
            var digit_name = (function(n){
                var names = ['zero', 'one', 'two'];
                
                return function (n) {
                    return names[n];
                } 
            }());

            console.log(digit_name(1));

            function fade(id){
                var dom = document.getElementById(id),
                    level = 1;
                function step() {
                    console.log(level);
                    var h = level.toString(16);
                    dom.style.backgroundColor = '#FFFF' + h + h;
                    if(level < 15){
                        level += 1;
                        setTimeout(step, 100);
                    }
                }
                
                setTimeout(step, 100);
            }

            function gizmo(id){
                return {
                    toString: function() {
                        return "gizmo" + id;
                    }
                };
            }

            function hoozit(id){
                var that = gizmo(id);
                that.test = function(testid){
                    return testid === id;
                };
                
                return that;
            }

            var my_hoozit = hoozit("SUCCESS");
            log(my_hoozit, my_hoozit.test("SUCCESS"));

            //1.
            function funky(o) {
                o = null;
            }

            var x = [];

            funky(x);
            log(x); //a. throw exception b. =null c. =[]

            //2.
            function swap(a, b){
                var temp = a;
                a = b;
                b = temp;
            }

            var x = 1, y = 2;
            swap(x, y);
            log(x); //a. 1 b.2 c.undefined d. throw exc

            //3. write add, sub and mul functions (should be as below)
            function add(a, b){
                return a+b;
            }
            function sub(a, b){
                return a-b;
            }
            function mul(a, b){
                return a*b;
            }
            log(add(3,4));
            log(sub(3,4));
            log(mul(3,4));

            //4. closure with 1 arg
            function identityf(o){
                return function(){
                    return o;
                }
            }

            var three = identityf(3);
            log(three());

            //5. closure with 2 args
            function addf(a){
                return function(b){
                    return add(a,b);
                }
            }
            log(addf(3)(4));

            //6. closure with 3 args: 2 numerical and one function which handles the 2 numbers
            function liftf(f){
                 return function(a1){
                    return function(b1){
                            return f(a1, b1);
                    };
                };
            }
            var addf1 = liftf(add);
            log(addf1(3)(4));
            log(liftf(mul)(5)(6));

            //7. curry function
            function curry(f, a){
                return function(b){
                    return f(a, b);
                }
            }

            var add3 = curry(add, 3);
            log(add3(4));
            log(curry(mul, 5)(6));

            //8. write increment function using existing functions
            var inc = addf(1);
            log(inc(5));

            var inc2 = liftf(add)(1);
            var inc3 = curry(add, 1);
            log(inc3(5));

            //9. write a func called "twice" 
            // that takes a binary func and return an unary func that passes its argument to the binary fun twice
            function twice(binaryFunc){
                return function(b){
                    return binaryFunc(b, b);
                }
            }

            var doubl = twice(add);
            log(doubl(11));
            var square = twice(mul);
            log(square(11));

            //10. write reverse, a func which reverses the arguments of a binary function
            function reverse(binary){
                return function(a, b){
                    return binary(b, a);
                }
            }

            var bus = reverse(sub);
            log(bus(3,2));

            //11. write a func compuseu that takes two unary functions and returns a unary func that calls them both
            function composeu(unaryFunc1, unaryFunc2){
                return function(a){
                    return unaryFunc2(unaryFunc1(a));
                }
            }
            log(composeu(doubl, square)(5));

            //12. write a func composeb that takes two binary funcs and returns a func that calls them both
            function composeb(bf1, bf2){
                return function(a, b, c){
                    return bf2(bf1(a,b), c);
                }
            }
            log(composeb(add, mul)(2, 3, 7));

            //13. write a limit func that allows a binary func to be called a limited number of times
            function limit(bf1, l){
                return function(a, b){
                    if(l >= 1){
                        l -= 1;
                        return bf1(a,b);
                    }
                    return undefined;
                }
            }

            var add_ltd = limit(add, 1);
            log(add_ltd(3, 4));
            log(add_ltd(3, 4));
            var mul_ltd = limit(mul, 2);
            log(mul_ltd(3, 4));
            log(mul_ltd(3, 4));
            log(mul_ltd(3, 4));

            //14. write a 'from' func that produces a generator that will produce produce a serioes of values
            function from(seed){
                return function(){
                    return seed++;
                }
            } 
            
            var index = from(0);
            log(index());
            log(index());
            log(index());

            //15. write a 'to' func which takes a generator and an end val and returns a generator that will produce numbers up to that limit
            function to(generator, endVal){
                return function(){
                    var nextVal = generator();
                    if(nextVal < endVal){
                        return nextVal;
                    }
                }
            } 

            var index = to(from(1), 3);
            log(index());
            log(index());
            log(index());

            //16. write a 'fromTo'that produces a generator that will produce values in a range
            function fromTo(startVal, endVal){
                return to(from(startVal), endVal);
            }

            var index = fromTo(0, 3);
            log(index());
            log(index());
            log(index());
            log(index());

            //17. write an 'element' func that takes an array and a generator and returns a generator that will produce elements from the array
            function element(arr, generatorFunc){
                return function(){
                    var nextVal = generatorFunc();
                    if(nextVal !== undefined){
                        return arr[nextVal];
                    }
                }
            }

            var ele = element(['a', 'b', 'c', 'd'], fromTo(1, 3));
            log(ele());
            log(ele());
            log(ele());

            //18. modify the 'element' function so that the generator argument is optional. 
            // If generator not provided => then each element of the array will be provided
            function element(arr, generatorFunc){
            var generator = generatorFunc !== undefined ? generatorFunc : fromTo(0, arr.length);
               return function(){
                    var nextVal = generator();
                    if(nextVal !== undefined){
                        return arr[nextVal];
                    }
                }
            }

            var ele = element(['a', 'b', 'c', 'd']);
            log(ele());
            log(ele());
            log(ele());
            log(ele());
            log(ele());

            //19. wite a 'collect' func that takes a generator and an array and produces a function  
            // that will collect the results (made inernally by the generator at every invocation of collect) in the array
            function collect(generator, arr){
                return function(){
                    var res = generator();
                    if(res !== undefined)
                    {
                        arr.push(res);
                    }

                    return res;
                }
            }

            var array = [],
                col = collect(fromTo(0, 2), array);
            log(col());
            log(col());
            log(col());
            log(array);

            //20. write a filter func that takes a generator and a predicate 
            // and produces a generator that produces only the values approved by the predicate
            function filter(generator, predicate){
                return function(){ 
                    var value;                  
                    do {
                        value = generator();
                    } while(value !== undefined && !predicate(value));

                    return value;
                }
            }

            var fil = filter(fromTo(0, 5), function third(value){
                return value % 3 === 0;
            });
            log(fil());
            log(fil());
            log(fil());

            //21. write a 'concat' function which takes 2 generators and produces a generator that combines the sequences
            function concat(gen1, gen2){
                var gen = gen1;
                return function(){
                    var value = gen();
                    if (value !== undefined){
                        return value;
                    }
                    gen = gen2;
                    return gen();
                }
            }

            var con = concat(fromTo(0, 3), fromTo(0, 2));
            log(con());
            log(con());
            log(con());
            log(con());
            log(con());
            log(con());

            //22. make a function 'gensymf' that makes a function that generates unique symbols
            function gensymf(symbol){
                var i = 0;
                return function(){
                    i += 1;
                    return symbol + i;
                }
            }

            var geng = gensymf("G");
            var genh = gensymf("H");

            log(geng());
            log(genh());
            log(geng());
            log(genh());

            //23. make a fibonaccif that returns a generator that will return the next fibonacci number
            function fibonaccif(i1, i2){
                var i = -1, next;               
                return function(){
                    i += 1;
                    if(i === 0){
                        return i1;
                    }
                    else if (i === 1){
                        return i2;
                    }
                    
                    next = i1 + i2;
                    i1 = i2;
                    i2 = next;
                    return next;
                }
            }

            var fib = fibonaccif(0, 1);
            log(fib());
            log(fib());
            log(fib());
            log(fib());
            log(fib());
            log(fib());

            function fibonaccif(i1, i2){
                return function(){
                    var next = i1;
                    i1 = i2;
                    i2 += next;
                    return next;
                }
            }
            fib = fibonaccif(0, 1);
            log(fib());
            log(fib());
            log(fib());
            log(fib());
            log(fib());
            log(fib());

            //24. write a counter function that returns an object containing 2 functions that implement 
            // an up/down counter, hiding the counter
            function counter(seed)
            {
                return {
                    up: function() {
                        seed += 1;
                        return seed;
                    },
                    down: function() {
                        seed -= 1;
                        return seed;
                    }
                };
            }

            var object = counter(10),
                up = object.up,
                down = object.down;
            log(up());
            log(down());
            log(down());
            log(up());

            //25. make a revocable function that takes a binary function and returns an object containing 
            // an invoke function that can invoke the binary function and a revoke function that disables the invoke function
            function revocable(binaryF){
                return {
                    invoke: function(a, b){
                        return binaryF === undefined ? undefined : binaryF(a, b);
                    },
                    revoke: function(){
                        binaryF = undefined;
                    }
                };
            }

            var rev = revocable(add);
            add_rev = rev.invoke;
            log(add_rev(3, 4));
            rev.revoke();
            log(add_rev(3, 4));

            //26. write a function m that takes a values and an optional source string and returns them in an object
            function m(value, source){
                return {
                    "value": value,
                    "source": typeof source === "string" ? source : String(value)
                };
            }

            log(JSON.stringify(m(1)));
            log(JSON.stringify(m(Math.PI, "pi")));

            //27. write a func 'addm' that takes two m objects and returns an m object 
            //(m have 2 properties. one is mandatory 'value' and the other is optional: 'source')
            function addm(m1, m2){
                return m(
                    m1.value + m2.value,
                    "("+m1.source+"+"+m2.source+")"
                );
            }

            log(JSON.stringify(addm(m(1), m(3))));
            log(JSON.stringify(addm(m(1), m(Math.PI, "pi"))));

            //28. write a function 'liftm' that takes a binary function and a string and returns a function that acts on m objects
            function liftm(binary, sign){
                return function(m1, m2){
                    return m(
                        binary(m1.value, m2.value),
                        "("+m1.source+sign+m2.source+")"
                    );
                }
            }

            var addm = liftm(add, "+");
            log(JSON.stringify(addm(m(1), m(3))));
            log(JSON.stringify(liftm(mul, "*")(m(4), m(3))));

            //29. modify liftm so that the functions it produces ca accept arguments that are either numbers or m objects
            function liftm(binary, sign){
                return function(a, b){
                    var value, source;
                    if(typeof a === 'number') {
                        a = m(a);
                    }
                    if(typeof b === 'number') {
                        b = m(b);
                    }
                    
                    return m(
                        binary(a.value, b.value), 
                        "("+a.source+sign+b.source+")"
                    );
                }
            }

            var addm = liftm(add, "+");
            log(JSON.stringify(addm(1, 3)));

            //30. write a function 'exp' that evaluates simple array expressions.
            function exp(arr){
                if(typeof arr === 'number'){
                    return arr;
                }
                var binaryF = arr.shift();
                return binaryF(arr.shift(), arr.shift());
            }

            function exp(value){
                return Array.isArray(value)
                ? value[0](value[1], value[2])
                : value;
            }
            var sae = [mul, 5, 11];
            log(exp(sae));
            log(exp(42));

            //31. Modify exp to evaluate nested array expressions
            function exp(value){
                if(!Array.isArray(value)) return value;
                var val1 = Array.isArray(value[1]) ? exp(value[1]) : value[1],
                    val2 = Array.isArray(value[2]) ? exp(value[2]) :value[2];
                return value.length === 3 
                    ? value[0](val1, val2) 
                    : value[0](val1)
            }

            function exp(value){
                if(!Array.isArray(value)) return value;
                return value[0](exp(value[1]), exp(value[2]));
            }

            var nae = [
                Math.sqrt,
                [
                    add,
                    [square, 3],
                    [square, 4]
                ]
            ];
            log(exp(nae));

            //32. write a function 'addg' which adds from many invocations until it sees an empty invocation (hint: it returns itself somehow)
            function addg(first){
                function more(next){
                    if(next === undefined) {
                        return first;
                    }

                    first += next;
                    return more;
                }
                if(first !== undefined){
                    return more;
                }
            }

            log(addg());//undefined
            log(addg(1)(2)(4)(8)());//15

            //33. write a func 'liftg' that will take a binary function and apply it to many invocations
            function liftg(binaryF){
                return function(first){
                    if(first === undefined){
                        return undefined;
                    }
                    return function more(next){
                        if(next === undefined){
                            return first;
                        }
                        first = binaryF(first, next);
                        return more;
                    }
                }
            }

            log(liftg(mul)());              //undefined
            log(liftg(mul)(3)());           //3
            log(liftg(mul)(1)(0)(4)(8)());  //0
            log(liftg(mul)(1)(2)(4)(8)());  //64

            //34. write a function 'arrayg' that will build an array from many invocations
            function arrayg(first){
                var returnArr = [];             
                function more(next){
                    if(next === undefined){
                        return returnArr;
                    }
                    returnArr.push(next);
                    return more;
                }

                return more(first);
            }

            log(arrayg());           //[]
            log(arrayg(3)());        //[3]
            log(arrayg(3)(4)(5)());  //[3,4,5]

            //35. make a 'continuize' function that takes a unary function and returns
            // a function that takes a callback and an argument
            function continuize(unaryF){
                return function(callback, arg){
                    return callback(unaryF(arg));
                }
            }

            sqrtc = continuize(Math.sqrt);
            sqrtc(log, 81); //9

            //36. write an array wrapper object with methods get store and append such that
            // an attacker cannot get access to the private array
            function vector(){  // this first attempt still can be attacked
                var array = [];
                return {
                    append: function(i){
                        array.push(i);
                    },
                    store: function(i, v) {
                        array[i] = v;
                    },
                    get: function(i){
                        return array[i];
                    }
                };
            }

            var myvector = vector();
            myvector.append(7);
            myvector.store(1, 8);
            log(myvector.get(1));
            
            //36.1. and now the attack happens!
            var mystack;
            myvector.store('push', function(){
                mystack = this;
            });
            myvector.append(1); // stash is array!
            log(mystack);

            function vector2(){  // we forcibly convert to a number by using the + sign!
                var array = [];
                return {
                    append: function(v){
                        array[array.length] = v;
                    },
                    store: function(i, v) {
                        array[+i] = v;
                    },
                    get: function(i){
                        return array[+i];
                    }
                };
            }

            //37. make a func 'pubsub' that makes a publish/subscribe object.
            // it will reliably deliver all publications to all subscribers in the right order.
            function pubsub(){
                var subscribersArr = [];
                return {
                    subscribe: function(subscriberFunc){
                        subscribersArr[subscribersArr.length] = subscriberFunc;
                    },
                    publish: function(event){
                        subscribersArr.forEach(function(subscriber){
                            subscriber(event);
                        });
                    }
                };
            }

            var my_pubsub = pubsub();
            my_pubsub.subscribe(log);
            function log2(message){console.log("log2", message);}
            my_pubsub.subscribe(log2);
            my_pubsub.publish("It works!");

            //37.1 hack the pubsub above!
            var my_pubsub = pubsub();
            my_pubsub.subscribe();  //kaboom! - this is the hack, passing a undefined subscriber
            my_pubsub.subscribe(log);
            try{
                my_pubsub.publish("It works?");
            }
            catch(exc){
                log(exc);
            }
            //37.2. fix the hack above
            function pubsub2(){
                var subscribersArr = [];
                return {
                    subscribe: function(subscriberFunc){
                        subscribersArr[subscribersArr.length] = subscriberFunc;
                    },
                    publish: function(event){
                        subscribersArr.forEach(function(subscriber){
                            try{
                                subscriber(event);  // adding try-catch we solve the invalid subscriber scenario
                            } catch(ignore) {}
                        });
                    }
                };
            }

            //37.3. another hack
            var my_pubsub = pubsub2();
            my_pubsub.publish = undefined;

            //37.4. fix the hack above
            function pubsub3(){
                var subscribers = [];
                return Object.freeze({  // with this nobody can assign the methods!
                    subscribe: function(subscriberFunc){
                        subscribers[subscribers.length] = subscriberFunc;
                    },
                    publish: function(event){
                        var i, length = subscribers.length;
                        for(i = 0; i < length; i+= 1)
                        try{
                            subscribers[i](event); 
                        } catch(ignore) {}
                    }
                });
            }

            var my_pubsub = pubsub3();
            my_pubsub.publish = undefined;
            log(my_pubsub);    

            //37.5. hack another one!
            var my_pubsub = pubsub3();
            my_pubsub.subscribe(log);
            my_pubsub.subscribe(function (){this.length = 0;}); // this is the hack! this keeps the context of the array!
            my_pubsub.subscribe(function log2(message){console.log("log22", message);});
            my_pubsub.publish("kaboom!");

            //37.6. fix the hack above!
            function pubsub4(){
                var subscribers = [];
                return Object.freeze({  
                    subscribe: function(subscriberFunc) {
                        subscribers[subscribers.length] = subscriberFunc;
                    },
                    publish: function(event){
                        subscribers.forEach(function (s){// adding for-each we don't keep the 'this' context
                            try{
                                s(event);  
                            } catch(ignore) {}
                        });
                    }
                });
            }

            var my_pubsub = pubsub4();
            my_pubsub.subscribe(log);
            my_pubsub.subscribe(function (){this.length = 0; log('kakaboom!', this);}); 
            my_pubsub.subscribe(function log2(message){console.log("log22", message);});
            my_pubsub.publish("kaboom2!");

            //37.7. perform yet another hack!
            var my_pubsub = pubsub4();
            my_pubsub.subscribe(function (msg){this.length = 0; log('kakaboom3!', msg, this);}); 
            my_pubsub.subscribe(function log3(message){console.log("log33", message);});
            my_pubsub.subscribe(limit(function (){
                my_pubsub.publish("out of order!"); // we subscribe with a publish!
            }, 2));
            my_pubsub.publish("kaboom3!");

            //37.8. fix the hack above!
            function pubsub5(){
                var subscribers = [];
                return Object.freeze({  
                    subscribe: function(subscriberFunc) {
                        subscribers[subscribers.length] = subscriberFunc;
                    },
                    publish: function(event){
                        subscribers.forEach(function (s){// adding for-each we don't keep the 'this' context
                            setTimeout(function(){
                                s(event);
                            }, 0); 
                        });
                    }
                });
            }

            var my_pubsub = pubsub5();
            my_pubsub.subscribe(function (msg){this.length = 0; log('kakaboom4!', msg, this);}); 
            my_pubsub.subscribe(function log3(message){console.log("log4", message);});
            my_pubsub.subscribe(limit(function (){
                my_pubsub.publish("out of order!"); // we subscribe with a publish!
            }, 2));
            my_pubsub.publish("kaboom4!");
    </script>
</document>